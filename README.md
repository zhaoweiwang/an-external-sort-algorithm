# an-external-sort-algorithm

**An implement case: external sort algorithm with 250 million double-precision floating-point number (by C++).**

**keywords:**  external-sort multithreading dou2str radix-sorting merge-sort tree-of-loser high-precision block-fetch

##1. 问题描述：##
输入文本由符合 IEEE 754 标准的 64 位的十进制浮点数构成，每两个浮点数之间以空格或者横向制表符或者换行符间隔，间隔符只有一个。不符合以上描述的文本都是非法字符。例如输入文本 input.txt： 内容如下（可能不标准，而且含有非法字符）：

```C++
3.14159268
6.62e-134
6.12345678E-11
0.618
-1000000
hello
```

输出文本是对输入文本排序后的结果，每个结果独占一行，需严格符合IEEE 754标准（特别要求：精确到小数点后17位），输出为普通的文本格式。非法字符可以删除，但须记录非法字符数目。理论上来说，不管谁实现的程序，对于相同的输入文本，输出的文本应该是一模一样的。例如以上的 input.txt 的输出结果应该是：

```C++
-1.00000000000000000E+006
6.62000000000000000E-134
6.12345678000000000E-011
6.18000000000000000E-001
3.14159268000000000E+001
```
##2. 内核模块##

###2.1 读取数据###

一开始，采用 fstream DataFile; DataFile >> Word; 直接逐条读取记录，在读取的过程中，采用自己编写的正则表达式去判断每一个字符串是否符合要求，结果，百万数据读取的时间为 1270.41 秒。很明显，这个方法是行不通的，为此感到无奈，走了太多弯路和浪费了太多精力，得到的却是一个糟糕的结果，不过明显可得知 I/O 次数对时间的影响有多大。随后，为了减少 I/O 次数，采用 fread()函数进行大数据块读取文件记录。

**这里遇到两个难题：**

（ 1）如何对内存中的字符串判断合法的双精度浮点数？

（ 2）如何将判断得到的合法双精度浮点数转换为浮点数？

**解决方法：**

利用判断语句判断是否遇到制表符、换行符和空格符等，然后截取合法子字符串，然后利用 atof()函数将其转为浮点数保存起来，这时候读取时间可以缩短到2.743 秒。但这还没有达到要求，对于 atof()系统函数的调用太耗费时间，所以这里自己写了一个字符串转字符串的函数 double Str2DouPro(const char * StrTemp)将字符串字符判断和逐步追加为 double 类型。 将其写为单独一个头文件 Str2Dou.h 以便调用。其中涉及两个主要函数 judge() 函数判断合法浮点数，以及 

```C++
int judge(string str, int len){

	for(int i = 0; i < len; i++){
	
		if((str[i] >= '0' && str[i] <= '9') || str[i] == '+' || str[i] == '-' || str[i] == '.' || str[i] == 'E' || str[i] == 'e'){
			if(str[i] == '+' || str[i] == '-'){
				if(i == 0 || str[i - 1] == 'E' || str[i - 1] == 'e')
					continue;
				else
					return 0;
			}
			else if(str[i] == 'E' || str[i] == 'e'){
				if(i != 0 && (str[i - 1] >= '0' && str[i - 1] <= '9'))
					continue;
				else
					return 0;
			}
			else if(str[i] == '.'){
				if(i != 0 && (str[i - 1] >= '0' && str[i - 1] <= '9') && (str[i + 1] >= '0' && str[i + 1] <= '9'))
					continue;
				else
					return 0;
			}
			else
				continue;
		
		}
		else
			return 0;
	
	}

	return 1;

}
```

### 时间： ###

一百万：0.861秒

一千万：7.087秒

五千万：43.69秒

二点五亿：211.707秒


### **程序目前存在的不足：**

1. 没有必要一个头文件（.h）对应一个源文件（.cpp），意义不大，反而造成定义在各个头文件中的全局参数引用混乱；

2. 代码不简练，一个是由于C操作用得多，相较于C++11中的vector、以及各式各样的stl库函数的方便而言，语言的局限性导致；另一个是当时能力有限，用了很多笨方法和编码习惯；

3. 没有必要使用传参形式来共享变量，为了提升速度直接采用全局变量即可。特别是内存占用较大的缓冲区，即使是引用传参，对速度的影响也较为明显，当时没有考虑到这一点。